import string
from pathlib import Path
from ctypes.util import find_library
import clang.cindex
from . import hppParser
from . import bindingGenerator
from . import hppSorter
from . import utils

clang.cindex.Config.set_library_file(find_library("libclang"))

__all__ = ["Parser", "Generator"]
__version__ = "1.0.0"
__author__ = "JasonLeon"
__copyright__ = "Copyright (c) 2025, JasonLeon"
__license__ = "MIT"

scan_hpp_files = utils.scan_hpp_files
Parser = hppParser.Parser
Generator = bindingGenerator.Generator
Sorter = hppSorter.Sorter


def generate_binding_from_hpp(
    common_module_name,
    hpp_root,
    hpp_file,
    output_file,
    includes,
    cpp_version,
    ignored_macros,
    REPLACE_TYPE,
    SPECIFIC_TYPE,
    IGNORE_TYPE,
    IGNORE_RETURN_TYPE,
    SPECIFIC_RETURN_TYPE,
    REPLACE_DEFAULT,
    IGNORED_MODULE,
    SPECIAL_REPLACE,
):
    parser = Parser(includes, hpp_root, hpp_file, cpp_version, ignored_macros)
    items = parser.get_dict()
    generator = Generator(
        common_module_name,
        items,
        REPLACE_TYPE,
        SPECIFIC_TYPE,
        IGNORE_TYPE,
        IGNORE_RETURN_TYPE,
        SPECIFIC_RETURN_TYPE,
        REPLACE_DEFAULT,
        IGNORED_MODULE,
        SPECIAL_REPLACE,
        hpp_file,
    )
    generator.emit_pybind_module(output_file)


def generate_hpp_file_from_hpp(
    read_file,
    hpp_file,
    output_file,
):
    with open(output_file, "w", encoding="utf-8") as f:
        file_names = Path(read_file).parts[-3:]
        real_include = "/".join(file_names)
        f.write(f'#include "{real_include}"\n')
        f.write(f'#include "A_utils.hpp"\n')
        f.write("namespace py = pybind11;\n\n")
        f.write(f"void bind_{hpp_file.split('.')[0]}(py::module &m); \n")
    print(f"Generated {output_file}")


def generate_pybind_main(common_module_name, source_files, output_filename):
    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(
                "// This file is automatically generated by the Python script and should not be modified manually.\n\n"
            )
            for filename in source_files:
                f.write(f'#include "{filename}"\n')
            f.write("\n")

            f.write("PYBIND11_MODULE(pysf, m) {\n")
            f.write('    m.doc() = "SFML Library";\n\n')
            f.write(f'    auto m_{common_module_name} = m.def_submodule("{common_module_name}");\n')

            for filename in source_files:
                if not "bind_" in filename:
                    continue

                base_name = Path(filename).name.split(".")[0]
                f.write(f"    {base_name}(m_{common_module_name});\n")

            f.write("}\n")

        print(f"Generated {output_filename}")
    except IOError as e:
        print(f"Error writing to {output_filename}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


def generate_cmakelists(source_files, self_files, python_version):
    output_filename = "CMakeLists.txt"
    try:
        sources = ""
        for filename in source_files:
            flag = False
            for self_file in self_files:
                if filename in self_file:
                    flag = True
                    break
            if flag:
                sources += f'    "src/{filename.split(".")[0]}.cpp"\n'
            else:
                sources += f'    "output/src/{filename.split(".")[0]}.cpp"\n'

        with open(f"{output_filename}.in") as template, open(output_filename, "w") as out:
            cmake_content = template.read().format(sources=sources, python_version=python_version)
            out.write(cmake_content)

        print(f"CMakeLists.txt generated successfully: {output_filename}")

    except IOError as e:
        print(f"Error writing to {output_filename}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
